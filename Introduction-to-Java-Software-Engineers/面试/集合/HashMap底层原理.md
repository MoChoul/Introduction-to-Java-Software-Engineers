在jdk1.8之前，底层是通过数组+链表实现的，当我们创建hashmap时会先创建一个数组，当我们用put方法存数据时，先根据key的hashcode值计算出hash值，然后用这个哈希值确定在数组中的位置，再把value值放进去，如果这个位置本来没放东西，就会直接放进去，如果之前就有，就会生成一个链表，把新放入的值放在头部，当用get方法取值时，会先根据key的hashcode值计算出hash值，确定位置，再根据equals方法从该位置上的链表中取出该value值，当容量超过当前容量的0.75倍之后，就会自动扩容为原来容量的2倍。这个0.75就是负载因子。

但是在jdk1.8之后，HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+ 红黑树组成。因为在1.7的时候，这个链表的长度不固定，所以如果key的hashcode重复之后，那么对应的链表的数据的长度就无法控制了，get数据的时间复杂度就取决于链表的长度了，为了提高这一部分的性能，加入了红黑树，如果链表的长度超过8位之后，会将链表转换为红黑树，极大的降低了时间复杂度

HashMap 线程不安全，即任一时刻可以有多个线程同时 写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。